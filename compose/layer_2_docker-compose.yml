version: '3.8'

networks:
  layer1_traefik-ingress:
    external: true
  monitoring-network:
    driver: overlay
    attachable: true
  postgres-network:
    driver: overlay
    attachable: true
  dgraph-network:
    driver: overlay
    attachable: true

volumes:
  redis-data:
  minio-data:
  influx-data:
  loki-data:
  grafana-data:
  dgraph-zero-data:
  dgraph-alpha-data:

configs:
  fluentd-config:
    file: ../layer_2/src/monitoring/config/fluentd.conf
  telegraf-config:
    file: ../layer_2/src/monitoring/config/telegraf.conf


services:
  redis:
    image: redislabs/rejson:2.0.7
    command: >
      --requirepass ${REDIS_PASSWORD}
      --loadmodule /usr/lib/redis/modules/rejson.so
      --loadmodule /usr/lib/redis/modules/redisearch.so
      --bind 0.0.0.0
      --protected-mode no
    volumes:
      - redis-data:/data
    networks:
      - layer1_traefik-ingress
    ports:
      - "${REDIS_PORT}:6379"
    deploy:
      # placement:
      #   constraints:
      #     - node.labels.role == storage
      labels:
        - "traefik.enable=false"

  minio:
    image: minio/minio:RELEASE.2025-07-23T15-54-02Z
    entrypoint: >
      /bin/sh -c "
      mkdir -p /data &&
      /usr/bin/minio server /data --console-address :9001
      "
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    volumes:
      - minio-data:/data
    networks:
      - layer1_traefik-ingress
    deploy:
      # placement:
      #   constraints:
      #     - node.labels.role == storage
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.minio-endpoint.rule=Host(`files.${HOSTNAME}`)"
        - "traefik.http.routers.minio-endpoint.service=minio-endpoint@docker"
        - "traefik.http.routers.minio-endpoint.entrypoints=websecure"
        - "traefik.http.routers.minio-endpoint.tls.certresolver=lets-encrypt-tls"
        - "traefik.http.services.minio-endpoint.loadbalancer.server.port=9000"
        - "traefik.http.routers.minio-console.rule=Host(`minio.${HOSTNAME}`)"
        - "traefik.http.routers.minio-console.service=minio-console@docker"
        - "traefik.http.routers.minio-console.entrypoints=websecure"
        - "traefik.http.routers.minio-console.tls.certresolver=lets-encrypt-tls"
        - "traefik.http.services.minio-console.loadbalancer.server.port=9001"

  minio-setup:
    image: minio/minio:RELEASE.2025-07-23T15-54-02Z
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
      MINIO_ACCESS_KEY: ${MINIO_ACCESS_KEY}
      MINIO_SECRET_KEY: ${MINIO_SECRET_KEY}
      MINIO_REPLAYS_BUCKET: ${MINIO_REPLAYS_BUCKET}
      MINIO_IMAGE_GENERATION_BUCKET: ${MINIO_IMAGE_GENERATION_BUCKET}
    networks:
      - layer1_traefik-ingress
    depends_on:
      - minio
    entrypoint: >
      /bin/sh -c "
      until mc ping --exit minio:9000; do
        echo 'Waiting for MinIO to be ready...'
        sleep 5
      done
      
      mc alias set minio http://minio:9000 $$MINIO_ROOT_USER $$MINIO_ROOT_PASSWORD
      
      if ! mc admin user svcacct info minio $$MINIO_ACCESS_KEY 2>/dev/null; then
        echo 'Creating service account...'
        mc admin user svcacct add --access-key $$MINIO_ACCESS_KEY --secret-key $$MINIO_SECRET_KEY minio $$MINIO_ROOT_USER
        echo 'Service account created successfully'
      else
        echo 'Service account already exists'
      fi
      
      mc mb minio/$$MINIO_REPLAYS_BUCKET --ignore-existing
      mc mb minio/$$MINIO_IMAGE_GENERATION_BUCKET --ignore-existing
      
      mc policy set public minio/$$MINIO_REPLAYS_BUCKET
      mc policy set public minio/$$MINIO_IMAGE_GENERATION_BUCKET
      
      echo 'MinIO setup completed'
      "
    deploy:
      mode: replicated
      replicas: 1
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 3

  influxdb:
    image: influxdb:2.6
    environment:
      DOCKER_INFLUXDB_INIT_MODE: setup
      DOCKER_INFLUXDB_INIT_USERNAME: admin
      DOCKER_INFLUXDB_INIT_PASSWORD: ${INFLUX_ADMIN_PASSWORD}
      DOCKER_INFLUXDB_INIT_ORG: sprocket
      DOCKER_INFLUXDB_INIT_BUCKET: metrics
      DOCKER_INFLUXDB_INIT_ADMIN_TOKEN: ${INFLUX_ADMIN_TOKEN}
    volumes:
      - influx-data:/var/lib/influxdb2
    networks:
      - monitoring-network
      - layer1_traefik-ingress
    deploy:
      # placement:
      #   constraints:
      #     - node.labels.role == storage
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.influx.rule=Host(`influx.${HOSTNAME}`)"
        - "traefik.http.routers.influx.entrypoints=websecure"
        - "traefik.http.routers.influx.tls.certresolver=lets-encrypt-tls"
        - "traefik.http.services.influx.loadbalancer.server.port=8086"

  loki:
    image: grafana/loki:2.8.0
    command: -config.file=/etc/loki/local-config.yaml
    volumes:
      - loki-data:/loki
    networks:
      - monitoring-network
    deploy:
      # placement:
      #   constraints:
      #     - node.labels.role == storage
      labels:
        - "traefik.enable=false"

  grafana:
    image: grafana/grafana:9.4.7
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_ADMIN_PASSWORD}
      GF_DATABASE_TYPE: postgres
      GF_DATABASE_HOST: ${POSTGRES_HOST}:${POSTGRES_PORT}
      GF_DATABASE_NAME: grafana
      GF_DATABASE_USER: ${POSTGRES_USERNAME}
      GF_DATABASE_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - grafana-data:/var/lib/grafana
    networks:
      - monitoring-network
      - layer1_traefik-ingress
      - postgres-network
    deploy:
      # placement:
      #   constraints:
      #     - node.labels.role == storage
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.grafana.rule=Host(`grafana.${HOSTNAME}`)"
        - "traefik.http.routers.grafana.entrypoints=websecure"
        - "traefik.http.routers.grafana.tls.certresolver=lets-encrypt-tls"
        - "traefik.http.services.grafana.loadbalancer.server.port=3000"

  fluentd:
    image: grafana/fluent-plugin-loki:main
    volumes:
      - /var/log:/var/log:ro
    networks:
      - monitoring-network
    configs:
      - source: fluentd-config
        target: /fluentd/etc/fluent.conf
    deploy:
      mode: global
      labels:
        - "traefik.enable=false"

  telegraf:
    image: telegraf:1.25
    environment:
      POSTGRES_HOST: ${POSTGRES_HOSTNAME}
      INFLUX_TOKEN: ${INFLUX_ADMIN_TOKEN}
      INFLUX_ORG: sprocket
      INFLUX_BUCKET: metrics
    networks:
      - monitoring-network
      - postgres-network
    configs:
      - source: telegraf-config
        target: /etc/telegraf/telegraf.conf
    deploy:
      mode: global
      labels:
        - "traefik.enable=false"

  dgraph-zero:
    image: dgraph/dgraph:latest
    command: dgraph zero --my=dgraph-zero:5080
    volumes:
      - dgraph-zero-data:/dgraph
    networks:
      - dgraph-network
    deploy:
      labels:
        - "traefik.enable=false"

  dgraph-alpha:
    image: dgraph/dgraph:latest
    command: dgraph alpha --my=dgraph-alpha:7080 --zero=dgraph-zero:5080
    volumes:
      - dgraph-alpha-data:/dgraph
    networks:
      - dgraph-network
      - layer1_traefik-ingress
    depends_on:
      - dgraph-zero
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.dgraph.rule=Host(`dgraph.${HOSTNAME}`)"
        - "traefik.http.routers.dgraph.entrypoints=websecure"
        - "traefik.http.routers.dgraph.tls.certresolver=lets-encrypt-tls"
        - "traefik.http.services.dgraph.loadbalancer.server.port=8080"

